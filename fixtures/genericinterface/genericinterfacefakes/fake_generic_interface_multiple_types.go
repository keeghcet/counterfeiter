// Code generated by counterfeiter. DO NOT EDIT.
package genericinterfacefakes

import (
	"sync"

	"github.com/maxbrunsfeld/counterfeiter/v6/fixtures/genericinterface"
)

type FakeGenericInterfaceMultipleTypes[T genericinterface.CustomTypeT, U genericinterface.CustomTypeU] struct {
	DoSomethingStub        func()
	doSomethingMutex       sync.RWMutex
	doSomethingArgsForCall []struct {
	}
	ReturnTStub        func() T
	returnTMutex       sync.RWMutex
	returnTArgsForCall []struct {
	}
	returnTReturns struct {
		result1 T
	}
	returnTReturnsOnCall map[int]struct {
		result1 T
	}
	ReturnTAndUStub        func() (T, U)
	returnTAndUMutex       sync.RWMutex
	returnTAndUArgsForCall []struct {
	}
	returnTAndUReturns struct {
		result1 T
		result2 U
	}
	returnTAndUReturnsOnCall map[int]struct {
		result1 T
		result2 U
	}
	ReturnUStub        func() U
	returnUMutex       sync.RWMutex
	returnUArgsForCall []struct {
	}
	returnUReturns struct {
		result1 U
	}
	returnUReturnsOnCall map[int]struct {
		result1 U
	}
	TakeAndReturnTStub        func(T) T
	takeAndReturnTMutex       sync.RWMutex
	takeAndReturnTArgsForCall []struct {
		arg1 T
	}
	takeAndReturnTReturns struct {
		result1 T
	}
	takeAndReturnTReturnsOnCall map[int]struct {
		result1 T
	}
	TakeAndReturnTAndUStub        func(T, U) (T, U)
	takeAndReturnTAndUMutex       sync.RWMutex
	takeAndReturnTAndUArgsForCall []struct {
		arg1 T
		arg2 U
	}
	takeAndReturnTAndUReturns struct {
		result1 T
		result2 U
	}
	takeAndReturnTAndUReturnsOnCall map[int]struct {
		result1 T
		result2 U
	}
	TakeAndReturnUStub        func(U) U
	takeAndReturnUMutex       sync.RWMutex
	takeAndReturnUArgsForCall []struct {
		arg1 U
	}
	takeAndReturnUReturns struct {
		result1 U
	}
	takeAndReturnUReturnsOnCall map[int]struct {
		result1 U
	}
	TakeTStub        func(T)
	takeTMutex       sync.RWMutex
	takeTArgsForCall []struct {
		arg1 T
	}
	TakeTAndReturnUStub        func(T) U
	takeTAndReturnUMutex       sync.RWMutex
	takeTAndReturnUArgsForCall []struct {
		arg1 T
	}
	takeTAndReturnUReturns struct {
		result1 U
	}
	takeTAndReturnUReturnsOnCall map[int]struct {
		result1 U
	}
	TakeTAndUStub        func(T, U)
	takeTAndUMutex       sync.RWMutex
	takeTAndUArgsForCall []struct {
		arg1 T
		arg2 U
	}
	TakeUStub        func(U)
	takeUMutex       sync.RWMutex
	takeUArgsForCall []struct {
		arg1 U
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) DoSomething() {
	fake.doSomethingMutex.Lock()
	fake.doSomethingArgsForCall = append(fake.doSomethingArgsForCall, struct {
	}{})
	stub := fake.DoSomethingStub
	fake.recordInvocation("DoSomething", []interface{}{})
	fake.doSomethingMutex.Unlock()
	if stub != nil {
		fake.DoSomethingStub()
	}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) DoSomethingCallCount() int {
	fake.doSomethingMutex.RLock()
	defer fake.doSomethingMutex.RUnlock()
	return len(fake.doSomethingArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) DoSomethingCalls(stub func()) {
	fake.doSomethingMutex.Lock()
	defer fake.doSomethingMutex.Unlock()
	fake.DoSomethingStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnT() T {
	fake.returnTMutex.Lock()
	ret, specificReturn := fake.returnTReturnsOnCall[len(fake.returnTArgsForCall)]
	fake.returnTArgsForCall = append(fake.returnTArgsForCall, struct {
	}{})
	stub := fake.ReturnTStub
	fakeReturns := fake.returnTReturns
	fake.recordInvocation("ReturnT", []interface{}{})
	fake.returnTMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTCallCount() int {
	fake.returnTMutex.RLock()
	defer fake.returnTMutex.RUnlock()
	return len(fake.returnTArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTCalls(stub func() T) {
	fake.returnTMutex.Lock()
	defer fake.returnTMutex.Unlock()
	fake.ReturnTStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTReturns(result1 T) {
	fake.returnTMutex.Lock()
	defer fake.returnTMutex.Unlock()
	fake.ReturnTStub = nil
	fake.returnTReturns = struct {
		result1 T
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTReturnsOnCall(i int, result1 T) {
	fake.returnTMutex.Lock()
	defer fake.returnTMutex.Unlock()
	fake.ReturnTStub = nil
	if fake.returnTReturnsOnCall == nil {
		fake.returnTReturnsOnCall = make(map[int]struct {
			result1 T
		})
	}
	fake.returnTReturnsOnCall[i] = struct {
		result1 T
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTAndU() (T, U) {
	fake.returnTAndUMutex.Lock()
	ret, specificReturn := fake.returnTAndUReturnsOnCall[len(fake.returnTAndUArgsForCall)]
	fake.returnTAndUArgsForCall = append(fake.returnTAndUArgsForCall, struct {
	}{})
	stub := fake.ReturnTAndUStub
	fakeReturns := fake.returnTAndUReturns
	fake.recordInvocation("ReturnTAndU", []interface{}{})
	fake.returnTAndUMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTAndUCallCount() int {
	fake.returnTAndUMutex.RLock()
	defer fake.returnTAndUMutex.RUnlock()
	return len(fake.returnTAndUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTAndUCalls(stub func() (T, U)) {
	fake.returnTAndUMutex.Lock()
	defer fake.returnTAndUMutex.Unlock()
	fake.ReturnTAndUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTAndUReturns(result1 T, result2 U) {
	fake.returnTAndUMutex.Lock()
	defer fake.returnTAndUMutex.Unlock()
	fake.ReturnTAndUStub = nil
	fake.returnTAndUReturns = struct {
		result1 T
		result2 U
	}{result1, result2}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTAndUReturnsOnCall(i int, result1 T, result2 U) {
	fake.returnTAndUMutex.Lock()
	defer fake.returnTAndUMutex.Unlock()
	fake.ReturnTAndUStub = nil
	if fake.returnTAndUReturnsOnCall == nil {
		fake.returnTAndUReturnsOnCall = make(map[int]struct {
			result1 T
			result2 U
		})
	}
	fake.returnTAndUReturnsOnCall[i] = struct {
		result1 T
		result2 U
	}{result1, result2}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnU() U {
	fake.returnUMutex.Lock()
	ret, specificReturn := fake.returnUReturnsOnCall[len(fake.returnUArgsForCall)]
	fake.returnUArgsForCall = append(fake.returnUArgsForCall, struct {
	}{})
	stub := fake.ReturnUStub
	fakeReturns := fake.returnUReturns
	fake.recordInvocation("ReturnU", []interface{}{})
	fake.returnUMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnUCallCount() int {
	fake.returnUMutex.RLock()
	defer fake.returnUMutex.RUnlock()
	return len(fake.returnUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnUCalls(stub func() U) {
	fake.returnUMutex.Lock()
	defer fake.returnUMutex.Unlock()
	fake.ReturnUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnUReturns(result1 U) {
	fake.returnUMutex.Lock()
	defer fake.returnUMutex.Unlock()
	fake.ReturnUStub = nil
	fake.returnUReturns = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnUReturnsOnCall(i int, result1 U) {
	fake.returnUMutex.Lock()
	defer fake.returnUMutex.Unlock()
	fake.ReturnUStub = nil
	if fake.returnUReturnsOnCall == nil {
		fake.returnUReturnsOnCall = make(map[int]struct {
			result1 U
		})
	}
	fake.returnUReturnsOnCall[i] = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnT(arg1 T) T {
	fake.takeAndReturnTMutex.Lock()
	ret, specificReturn := fake.takeAndReturnTReturnsOnCall[len(fake.takeAndReturnTArgsForCall)]
	fake.takeAndReturnTArgsForCall = append(fake.takeAndReturnTArgsForCall, struct {
		arg1 T
	}{arg1})
	stub := fake.TakeAndReturnTStub
	fakeReturns := fake.takeAndReturnTReturns
	fake.recordInvocation("TakeAndReturnT", []interface{}{arg1})
	fake.takeAndReturnTMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTCallCount() int {
	fake.takeAndReturnTMutex.RLock()
	defer fake.takeAndReturnTMutex.RUnlock()
	return len(fake.takeAndReturnTArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTCalls(stub func(T) T) {
	fake.takeAndReturnTMutex.Lock()
	defer fake.takeAndReturnTMutex.Unlock()
	fake.TakeAndReturnTStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTArgsForCall(i int) T {
	fake.takeAndReturnTMutex.RLock()
	defer fake.takeAndReturnTMutex.RUnlock()
	argsForCall := fake.takeAndReturnTArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTReturns(result1 T) {
	fake.takeAndReturnTMutex.Lock()
	defer fake.takeAndReturnTMutex.Unlock()
	fake.TakeAndReturnTStub = nil
	fake.takeAndReturnTReturns = struct {
		result1 T
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTReturnsOnCall(i int, result1 T) {
	fake.takeAndReturnTMutex.Lock()
	defer fake.takeAndReturnTMutex.Unlock()
	fake.TakeAndReturnTStub = nil
	if fake.takeAndReturnTReturnsOnCall == nil {
		fake.takeAndReturnTReturnsOnCall = make(map[int]struct {
			result1 T
		})
	}
	fake.takeAndReturnTReturnsOnCall[i] = struct {
		result1 T
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndU(arg1 T, arg2 U) (T, U) {
	fake.takeAndReturnTAndUMutex.Lock()
	ret, specificReturn := fake.takeAndReturnTAndUReturnsOnCall[len(fake.takeAndReturnTAndUArgsForCall)]
	fake.takeAndReturnTAndUArgsForCall = append(fake.takeAndReturnTAndUArgsForCall, struct {
		arg1 T
		arg2 U
	}{arg1, arg2})
	stub := fake.TakeAndReturnTAndUStub
	fakeReturns := fake.takeAndReturnTAndUReturns
	fake.recordInvocation("TakeAndReturnTAndU", []interface{}{arg1, arg2})
	fake.takeAndReturnTAndUMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndUCallCount() int {
	fake.takeAndReturnTAndUMutex.RLock()
	defer fake.takeAndReturnTAndUMutex.RUnlock()
	return len(fake.takeAndReturnTAndUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndUCalls(stub func(T, U) (T, U)) {
	fake.takeAndReturnTAndUMutex.Lock()
	defer fake.takeAndReturnTAndUMutex.Unlock()
	fake.TakeAndReturnTAndUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndUArgsForCall(i int) (T, U) {
	fake.takeAndReturnTAndUMutex.RLock()
	defer fake.takeAndReturnTAndUMutex.RUnlock()
	argsForCall := fake.takeAndReturnTAndUArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndUReturns(result1 T, result2 U) {
	fake.takeAndReturnTAndUMutex.Lock()
	defer fake.takeAndReturnTAndUMutex.Unlock()
	fake.TakeAndReturnTAndUStub = nil
	fake.takeAndReturnTAndUReturns = struct {
		result1 T
		result2 U
	}{result1, result2}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndUReturnsOnCall(i int, result1 T, result2 U) {
	fake.takeAndReturnTAndUMutex.Lock()
	defer fake.takeAndReturnTAndUMutex.Unlock()
	fake.TakeAndReturnTAndUStub = nil
	if fake.takeAndReturnTAndUReturnsOnCall == nil {
		fake.takeAndReturnTAndUReturnsOnCall = make(map[int]struct {
			result1 T
			result2 U
		})
	}
	fake.takeAndReturnTAndUReturnsOnCall[i] = struct {
		result1 T
		result2 U
	}{result1, result2}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnU(arg1 U) U {
	fake.takeAndReturnUMutex.Lock()
	ret, specificReturn := fake.takeAndReturnUReturnsOnCall[len(fake.takeAndReturnUArgsForCall)]
	fake.takeAndReturnUArgsForCall = append(fake.takeAndReturnUArgsForCall, struct {
		arg1 U
	}{arg1})
	stub := fake.TakeAndReturnUStub
	fakeReturns := fake.takeAndReturnUReturns
	fake.recordInvocation("TakeAndReturnU", []interface{}{arg1})
	fake.takeAndReturnUMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnUCallCount() int {
	fake.takeAndReturnUMutex.RLock()
	defer fake.takeAndReturnUMutex.RUnlock()
	return len(fake.takeAndReturnUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnUCalls(stub func(U) U) {
	fake.takeAndReturnUMutex.Lock()
	defer fake.takeAndReturnUMutex.Unlock()
	fake.TakeAndReturnUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnUArgsForCall(i int) U {
	fake.takeAndReturnUMutex.RLock()
	defer fake.takeAndReturnUMutex.RUnlock()
	argsForCall := fake.takeAndReturnUArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnUReturns(result1 U) {
	fake.takeAndReturnUMutex.Lock()
	defer fake.takeAndReturnUMutex.Unlock()
	fake.TakeAndReturnUStub = nil
	fake.takeAndReturnUReturns = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnUReturnsOnCall(i int, result1 U) {
	fake.takeAndReturnUMutex.Lock()
	defer fake.takeAndReturnUMutex.Unlock()
	fake.TakeAndReturnUStub = nil
	if fake.takeAndReturnUReturnsOnCall == nil {
		fake.takeAndReturnUReturnsOnCall = make(map[int]struct {
			result1 U
		})
	}
	fake.takeAndReturnUReturnsOnCall[i] = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeT(arg1 T) {
	fake.takeTMutex.Lock()
	fake.takeTArgsForCall = append(fake.takeTArgsForCall, struct {
		arg1 T
	}{arg1})
	stub := fake.TakeTStub
	fake.recordInvocation("TakeT", []interface{}{arg1})
	fake.takeTMutex.Unlock()
	if stub != nil {
		fake.TakeTStub(arg1)
	}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTCallCount() int {
	fake.takeTMutex.RLock()
	defer fake.takeTMutex.RUnlock()
	return len(fake.takeTArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTCalls(stub func(T)) {
	fake.takeTMutex.Lock()
	defer fake.takeTMutex.Unlock()
	fake.TakeTStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTArgsForCall(i int) T {
	fake.takeTMutex.RLock()
	defer fake.takeTMutex.RUnlock()
	argsForCall := fake.takeTArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnU(arg1 T) U {
	fake.takeTAndReturnUMutex.Lock()
	ret, specificReturn := fake.takeTAndReturnUReturnsOnCall[len(fake.takeTAndReturnUArgsForCall)]
	fake.takeTAndReturnUArgsForCall = append(fake.takeTAndReturnUArgsForCall, struct {
		arg1 T
	}{arg1})
	stub := fake.TakeTAndReturnUStub
	fakeReturns := fake.takeTAndReturnUReturns
	fake.recordInvocation("TakeTAndReturnU", []interface{}{arg1})
	fake.takeTAndReturnUMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnUCallCount() int {
	fake.takeTAndReturnUMutex.RLock()
	defer fake.takeTAndReturnUMutex.RUnlock()
	return len(fake.takeTAndReturnUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnUCalls(stub func(T) U) {
	fake.takeTAndReturnUMutex.Lock()
	defer fake.takeTAndReturnUMutex.Unlock()
	fake.TakeTAndReturnUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnUArgsForCall(i int) T {
	fake.takeTAndReturnUMutex.RLock()
	defer fake.takeTAndReturnUMutex.RUnlock()
	argsForCall := fake.takeTAndReturnUArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnUReturns(result1 U) {
	fake.takeTAndReturnUMutex.Lock()
	defer fake.takeTAndReturnUMutex.Unlock()
	fake.TakeTAndReturnUStub = nil
	fake.takeTAndReturnUReturns = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnUReturnsOnCall(i int, result1 U) {
	fake.takeTAndReturnUMutex.Lock()
	defer fake.takeTAndReturnUMutex.Unlock()
	fake.TakeTAndReturnUStub = nil
	if fake.takeTAndReturnUReturnsOnCall == nil {
		fake.takeTAndReturnUReturnsOnCall = make(map[int]struct {
			result1 U
		})
	}
	fake.takeTAndReturnUReturnsOnCall[i] = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndU(arg1 T, arg2 U) {
	fake.takeTAndUMutex.Lock()
	fake.takeTAndUArgsForCall = append(fake.takeTAndUArgsForCall, struct {
		arg1 T
		arg2 U
	}{arg1, arg2})
	stub := fake.TakeTAndUStub
	fake.recordInvocation("TakeTAndU", []interface{}{arg1, arg2})
	fake.takeTAndUMutex.Unlock()
	if stub != nil {
		fake.TakeTAndUStub(arg1, arg2)
	}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndUCallCount() int {
	fake.takeTAndUMutex.RLock()
	defer fake.takeTAndUMutex.RUnlock()
	return len(fake.takeTAndUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndUCalls(stub func(T, U)) {
	fake.takeTAndUMutex.Lock()
	defer fake.takeTAndUMutex.Unlock()
	fake.TakeTAndUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndUArgsForCall(i int) (T, U) {
	fake.takeTAndUMutex.RLock()
	defer fake.takeTAndUMutex.RUnlock()
	argsForCall := fake.takeTAndUArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeU(arg1 U) {
	fake.takeUMutex.Lock()
	fake.takeUArgsForCall = append(fake.takeUArgsForCall, struct {
		arg1 U
	}{arg1})
	stub := fake.TakeUStub
	fake.recordInvocation("TakeU", []interface{}{arg1})
	fake.takeUMutex.Unlock()
	if stub != nil {
		fake.TakeUStub(arg1)
	}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeUCallCount() int {
	fake.takeUMutex.RLock()
	defer fake.takeUMutex.RUnlock()
	return len(fake.takeUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeUCalls(stub func(U)) {
	fake.takeUMutex.Lock()
	defer fake.takeUMutex.Unlock()
	fake.TakeUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeUArgsForCall(i int) U {
	fake.takeUMutex.RLock()
	defer fake.takeUMutex.RUnlock()
	argsForCall := fake.takeUArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ genericinterface.GenericInterfaceMultipleTypes[genericinterface.CustomTypeT, genericinterface.CustomTypeU] = new(FakeGenericInterfaceMultipleTypes[genericinterface.CustomTypeT, genericinterface.CustomTypeU])
